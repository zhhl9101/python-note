# Dijkstra算法
<p align="right">2021年4月，时间结余。</p>

---
### 1.介绍

- 提出者：1959年，荷兰计算机科学家**狄克斯特拉** 。

- 中文名：迪杰斯特拉算法，迪克斯特拉算法，狄克斯特拉算法。

- 描述 ：从一个点到其余各个点的**最短路径**算法，解决的是**有权图**中最短路径问题。即从图中的某个点出发到达另外一个点所经过的边的权重之和最小的一条路径。从起点开始，遍历离起点距离最近且未访问过的点，然后将该点作为起点继续遍历，直到扩展到终点。

- 特点：
	1. 一次遍历能够得到从起点到遍历过的所有点的最短路径。
	2. 无方向扩散，直到遍历到目标点，效率不高。
	3. 无法处理权重有负值的情况。

---

### 2.食用

什么是有权图？

有权图对应的是无权图，这里的**权**指的是权重，权重可以理解为**代价**。现实中，代价可以指两个城市之间的距离，也可以指从一个城市去到另一个城市的花费，等等。比如：从西安到北京的距离是1100km，我们就可以表示为西安到北京的权重为1100。

无权图如下所示：

 <img src="..\pictures\no-weight.png" title="无权图" width="400px" height="200px">
&nbsp;

有权图如下所示：

 <img src="..\pictures\weight.png" title="有权图" width="400px" height="200px">

以上面的有权图为例，从 **A** 到 **B** 的距离是 **5km**，从 **A** 到 **C** 的距离是 **1km**，以此类推。

问题来了，法外狂徒 张三 在 **A** 城市犯案，现在要逃往 **D** 城市躲起来，走哪条路线最近呢？



张三 想到了dijkstra算法。

要求从 **A** 到 **D** 的最短路径，他需要知道2个东西：a)路径， b)总距离。

其中，路径 形如 A->B->D, 我们可以用一个字典dict存储每个点的爸爸。

比如：**parent_dict** = { 'A':None, 'B':'A', 'D':'B' } 表示 **A** 的爸爸是None，即没有爸爸，它就是最开始被生活所迫的第一只鸡，以后才有了鸡蛋 **B** ... ，**B** 的爸爸是 **A** ，即 **B** 是从 **A** 走过来的，同理，**D** 是从 **B** 走过来的，所以想知道怎么去到 **D** , 我们就得先去 **B**， 怎么去 **B** ，我们得先去 **A** ，怎么去 **A** ，我们就在 **A**，于是，就有了路径 A->B->D。

于是，就有了自底向上的思想，从后往前解决问题。现实中，一旦用户有了问题，利益相关者想的总是解决提出问题的人，然后就没有问题了，这种自顶向下的思考方式是不对的。应该先解决自己的问题，再解决中间问题，最后自然而然就解决了用户的问题。

再次，总距离 怎么得到呢？我们还可以用一个字典dict存储从 **A** 点到该点的总距离。

比如：**distance_dict** = { 'A':0, 'B':5, 'C':1 } 表示 从 **A** 到 **A** 的总距离是 0，从 **A** 到 **B** 的总距离是 5，从 **A** 到 **C** 的总距离是 1，以此类推。



于是，张三 开始模拟算法流程：

0）定义一个列表list存储未走到的城市，即**queue_list**；定义一个列表list(或集合set)存储已经走过的城市，防止走第2遍，即**visited_list**。

1）从 **A** 可以直达 **B** 或 **C** 




---

### 3.代码

---

### 附录

1. B站 [从BFS到Dijkstra算法](https://www.bilibili.com/video/BV1ts41157Sy/?spm_id_from=333.788.recommend_more_video.-1)